# object-study

## 1. 객체, 설계

로버트 마틴 <클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법>에서 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다.
> 모든 소프트웨어 모듈에는 세 가지 목적이 있다.
> 1. 실행 중에 제대로 동작하는 것
> 2. 목적은 변경을 위해 존재하는 것
> 3. 코드를 읽는 사람과 의사소통하는 것

### 변경에 취약한 코드
의존성이라는 말 속에는 `어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다`는 사실이 내포돼 있다.

그렇다고 해서 객체 사이의 의존성을 완전히 없애는 것이 정답은 아니다.
객체지향 설계: 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것
- 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지, 불필요한 의존성 제거

의존성이 과하다 = 결합도(Coupling)가 높다.

### 캡슐화
- 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것
- 변경하기 쉬운 객체를 만드는 것
- 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있다

### 응집도
- 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 `응집도`가 높다고 말함
- 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 함.

객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것

> *_객체 내부의 상태를 `캡슐화`하고 객체 간에 오직 `메시지`를 통해서만 상호작용하도록 만드는 것_*
> 
> 외부의 간섭을 최대한 베재하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길이다.
> 

### 책임의 이동
- 객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다.
- 각 객체는 자신을 스스로 책임진다.

### 의인화
- 비록 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든것이 능동적이고 자율적인 존재로 바뀐다.
- 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙
- 대상이 비록 실세계에서는 생명이 없는 수동적인 존재라고 하더라도 객체지향의 세계로 넘어오는 순간 그들은 생명과 지능을 가진 싱싱한 존재로 다시 태어난다.

---
## 객체지향 설계
> *설계란? 코드를 배치하는 것*
> 

#### 좋은 설계란?
- 기능을 구현하는 코드를 짜야 하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야한다.
- 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다.


> __변경 가능한 코드 = 이해하기 쉬운 코드__


---
## 2.객체지향 프로그래밍
객체지향 프로그램을 작성할 때 가정 먼저 고려하는 것은 무엇인가?

클래스? → 속성과 메소드

객체지향은 말 그대로 객체를 지향하는 것이다.

클래스가 아닌 `객체`에 초점을 맞춰야 한다.

> 객체: 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재

1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
    - 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 갖는지를 먼저 결정해야 한다.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.
    - 객체 지향적으로 생각하고 싶다면 객체를 고립된 존재로 바라보지 말고 협력에 참여하는 협력자로 바라봐야 한다.

### 도메인의 구조를 따르는 프로그램 구조

소프트웨어는 사용자가 원하는 어떤 문제를 해결하기 위해 만들어진다.

문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 `도메인` 이라고 부른다.

### 클래스 구현

클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 `공개`하고 어떤 부분을 `감출지`를 결정하는 것이다. → 왜? 경계의 명확성이 객체의 자율성을 보장하기 때문이다.

캡슐화라는 특징을 갖고 있으며, 외부에서의 접근을 통제할 수 있는 `접근 제어(access control)` 메커니즘도 함께 제공한다. 접근 제어를 위해 public, protected, private과 같은 `접근 수정자(access modifier)`를 제공한다.
